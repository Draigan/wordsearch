#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define RESET "\033[0m"
#define RED "\033[31m"

#define GRID_ROWS 8
#define GRID_COLS 7
#define GRID_DEPTH 2
#define WORDS_LENGTH 8
#define MAX_WORD_LENGTH 10
typedef int bool;
#define true 1
#define false 0

#define POSS_LENGTH GRID_ROWS *GRID_COLS * 8
typedef struct {
  int length;
  char directions[POSS_LENGTH][3];
  int coordinates[POSS_LENGTH][3];

} possibilities;

// Puzzle grid
char grid[GRID_ROWS][GRID_COLS][GRID_DEPTH];
// Array to mark which words have been used
int used_words[WORDS_LENGTH] = {0};
// Words to be placed
char words[WORDS_LENGTH][MAX_WORD_LENGTH] = {
    "COOL", "FOOL", "DINO", "NICE", "LOVE", "OCTOPUS", "DRAGON", "FAIRY"};

// Possible directions a word can move
char *directions[] = {"u", "d", "l", "r", "ul", "ur", "dl", "dr"};
// Number of words placed
int words_placed = 0;

// Get random number between 0 and max
int random_number(int max) { return rand() % max; }

// Make a GRID_ROWS * GRID_COLS grid of 'X'
void initialize_grid() {
  for (int i = 0; i < GRID_ROWS; i++) {
    for (int j = 0; j < GRID_COLS; j++) {
      strcpy(grid[i][j], "X");
    }
  }
}
/* Get a random point on the grid
 * @return - array[0] is row & array[1] is col */
int *random_coordinates() {
  int row = random_number(GRID_ROWS);
  int col = random_number(GRID_COLS);
  int *coordinates = (int *)malloc(2 * sizeof(int));
  coordinates[0] = row;
  coordinates[1] = col;

  return coordinates;
}

/*
 * @Param1 - direction ("u", "d" "l", "r", "ul" "ur", "dl", "dr")
 * @Param2 - row to modify
 * @Param3 - col to modify
 * @return - array[0] is row & array[1] is col
 * */
int *get_direction(char *direction, int row, int col) {
  if (strcmp(direction, "u") == 0) {
    row -= 1;
  } else if (strcmp(direction, "d") == 0) {
    row += 1;
  } else if (strcmp(direction, "l") == 0) {
    col -= 1;
  } else if (strcmp(direction, "r") == 0) {
    col += 1;
  } else if (strcmp(direction, "ul") == 0) {
    row -= 1;
    col -= 1;
  } else if (strcmp(direction, "ur") == 0) {
    row -= 1;
    col += 1;
  } else if (strcmp(direction, "dl") == 0) {
    row += 1;
    col -= 1;
  } else if (strcmp(direction, "dr") == 0) {
    row += 1;
    col += 1;
  }

  int *directions = (int *)malloc(2 * sizeof(int));
  directions[0] = row;
  directions[1] = col;

  return directions;
}

bool check_space(char *word, char *direction, int row, int col, int n) {
  int length = strlen(word);
  char current_letter = word[n];

  if (n == 0) {
    printf("checking space for  %s\n", word);
  }

  // Reached the end of the word
  if (n >= length) {
    printf("There is space for: %s at n: %i \n", word, n);
    return true;
  }

  // Out of bounds
  if (row >= GRID_ROWS || col >= GRID_COLS || row < 0 || col < 0) {
    printf("Out of bounds at n: %i \n", n);
    return false;
  }

  // Encountered letter of different type
  if (grid[row][col][0] != 'X' && grid[row][col][0] != current_letter) {
    printf("encountered letter of different type\n");
    return false;
  }

  /* printf("Checking position [%d][%d], grid contains: %c, current letter:
   * %c\n", */
  /*        row, col, grid[row][col][0], current_letter); */

  // Adjust col/row based on direction
  int *directions = get_direction(direction, row, col);
  row = directions[0];
  col = directions[1];
  free(directions);

  return check_space(word, direction, row, col, n + 1);
}

/*
 * @Param1 - word we want to place
 * @Param2 - index of the char (call it with 0)
 * @Param3 - row where the first letter of the word is placed
 * @Param3 - col as above
 * @Param4 - direction ("u", "d" "l", "r", "ul" "ur", "dl", "dr")
 * @Param5 - Grid to place it in
 * */
void place_word(char *word, int index, int row, int col, char *direction,
                char grid[GRID_ROWS][GRID_COLS][GRID_DEPTH]) {

  // Placed all letters of the word on the grid
  if (index >= strlen(word)) {
    return;
  }

  // Adjust coords +1 or -1 to row / col
  if (index != 0) {
    int *directions = get_direction(direction, row, col);
    row = directions[0];
    col = directions[1];
    free(directions);
  }

  // Add the letter to grid
  grid[row][col][0] = word[index];
  grid[row][col][1] = '\0';
  /* strncpy(grid[row][col], &word[index], 1); */
  // Move on to the next letter
  return place_word(word, index + 1, row, col, direction, grid);
}

// Print the grid
void print_grid(char grid[GRID_ROWS][GRID_COLS][GRID_DEPTH]) {

  for (int i = 0; i < GRID_ROWS; i++) {
    for (int j = 0; j < GRID_COLS; j++) {
      if (grid[i][j][0] == 'X') {
        printf("%s ", grid[i][j]);
      } else {
        printf(RED "%s " RESET, grid[i][j]);
      }
    }
    printf("\n");
  }
}

// @return - random word that hasn't been used before
char *random_word(char words[WORDS_LENGTH][MAX_WORD_LENGTH],
                  int used_words[WORDS_LENGTH]) {
  int index;
  do {
    index = random_number(WORDS_LENGTH);
  } while (used_words[index]);
  used_words[index] = 1;

  return words[index];
}

/*
 * @Param1 - array mapping used words 0 is unused 1 is used
 * @return - false if all words are not placed else true
 * */
bool is_all_placed(int used_words[WORDS_LENGTH]) {

  for (int i = 0; i < WORDS_LENGTH; i++) {
    if (used_words[i] == 0) {
      return false;
    }
  }
  return true;
}

// Shuffle the directions array so that when we iterate over it, its not in the
// same order everytime
void shuffle_directions(char **directions) {

  for (int i = 7; i >= 0; i--) {
    // random number 0 to length
    int j = random_number(8);
    char *temp = directions[i];
    directions[i] = directions[j];
    directions[j] = temp;
  }
}

void push_coords(possibilities *poss, int row, int col) {
  /* printf("Pushing to row: %i", row); */
  /* printf("Pushing to col: %i", col); */
  poss->coordinates[poss->length][0] = row;
  poss->coordinates[poss->length][1] = col;
}

void push_direc(char directions[GRID_ROWS * GRID_COLS][3], char *direction) {
  for (int i = 0; i < GRID_ROWS * GRID_COLS * 8; i++) {
    if (directions[i][0] == '\0') {
      /* printf("recieved: %s", direction); */
      strcpy(directions[i], direction);
      return;
    }
  }
}

possibilities get_all_possible(char *word) {

  possibilities possible = {0};

  // For each square
  for (int i = 0; i < GRID_ROWS; i++) {
    for (int j = 0; j < GRID_COLS; j++) {
      // There are 8 directions
      for (int k = 0; k < 8; k++) {
        // Check each direction if the word is possible
        if (check_space(word, directions[k], i, j, 0)) {
          // Add it to our output
          push_direc(possible.directions, directions[k]);
          push_coords(&possible, i, j);
          possible.length++;
        }
      }
    }
  }

  return possible;
}

char *eraser(int length) {
  char *eraser = (char *)malloc((length + 1) * sizeof(char));
  for (int i = 0; i < length; i++) {
    eraser[i] = 'X';
  }
  eraser[length] = '\0';
  return eraser;
}

void solve(char grid[GRID_ROWS][GRID_COLS][GRID_DEPTH],
           char words[WORDS_LENGTH][MAX_WORD_LENGTH], int *used_words) {

  int row;
  int col;
  char *direction;
  bool deadend = true;

  // Get a random word
  char *word = random_word(words, used_words);

  // Char of the same length as word containing X's
  char *word_eraser = eraser(strlen(word));

  // Get all possible word placements
  possibilities poss = get_all_possible(word);

  if (is_all_placed(used_words)) {
    print_grid(grid);
    return;
  }
  // poss.directions and poss.coordinates corolate with eachother so
  // directions[0] and coordinates[0][0] + coordinates[0][1] will give us data
  // like "d" 0 , 0 meaning at the position 0 , 0 the word can be placed
  // downwards

  // Get random possibility
  int poss_position = random_number(poss.length);
  direction = poss.directions[poss_position];
  row = poss.coordinates[poss_position][0];
  col = poss.coordinates[poss_position][1];

  // Place the word in a random possibilitiy
  place_word(word, 0, row, col, direction, grid);

  // If we are not done, we need to check to make sure there are possibilities
  // for any of our remaining words

  // For every word in words
  for (int i = 0; i < WORDS_LENGTH; i++) {
    // Only select words that havnt't been used
    if (used_words[i] == 0) {
      // If we find a word that hasn't been used that has a possibility
      if (get_all_possible(words[i]).length != 0) {
        // Then we know this isn't a dead end
        deadend = false;
      }
    }
  }
  // Getting into iffy territory but I think we need to
  solve(grid, words, used_words);
  // Backtrack - Refill with X's
  place_word(word_eraser, 0, row, col, direction, grid);
}

// Print possible directions
void print_direct(possibilities *poss) {

  // For each element of the possibilities arrays
  printf("\n");
  for (int i = 0; i < POSS_LENGTH; i++) {
    // Stop when we reach the end of "directions"
    if (directions[i][0] == '\0') {
      return;
    }
    printf("row: %i, col: %i, direction: %s", poss->coordinates[i][0],
           poss->coordinates[i][1], directions[i]);
    printf("\n");
  }
}
void solve2(char grid[GRID_ROWS][GRID_COLS][GRID_DEPTH],
            char words[WORDS_LENGTH][MAX_WORD_LENGTH], int *used_words) {
  int rounds = 0;
  // If all words are placed, we are done
  if (words_placed == 8) {
    return;
  }

  do {
    ++rounds;
    printf("%i ", rounds);
    if (rounds >= 10000) {
      initialize_grid();
    }
    // Shuffle directions so, for example, it doesnt start with "u"
    shuffle_directions(directions);
    // Get a random word
    char *word = random_word(words, used_words);
    // Choose a random coord
    int *coordinates = random_coordinates();
    int row = coordinates[0];
    int col = coordinates[1];
    // Loop goes through the different directions stopping  when one
    for (int i = 0; i < sizeof(directions) / sizeof(directions[0]); i++) {
      // If a word fits at the coords with the direction, place it and
      if (check_space(word, directions[i], row, col, 0)) {
        place_word(word, 0, row, col, directions[i], grid);
        printf("Placing word %s at row: %i col: %i\n", word, row, col);
        words_placed += 1;
        printf("Placed words: %i\n", words_placed);
        break;
      }
    }
    free(coordinates);
  } while (words_placed < WORDS_LENGTH);
  print_grid(grid);
}

int main() {
  srand(time(NULL));

  // Initialize grid with "0"
  initialize_grid();
  /* place_word("cool", 0, 0, 9, "r", grid); */
  /* if (check_space("tool", "r", 0, 8, 0)) { */
  /*   place_word("tool", 0, 0, 8, "r", grid); */
  /* } */
  /* print_grid(grid); */
  /* place_word("cool", 0, 0, 0, "d", grid); */
  /* place_word("cool", 0, 8, -1, "r", grid); */
  /* place_word("cool", 0, 9, 0, "r", grid); */
  /* place_word("cool", 0, 9, 0, "u", grid); */
  /* if (check_space("cool", "r", 0, 9, 0)) { */
  /* } */
  /* solve2(grid, words, used_words); */
  /* possibilities possible = get_all_possible("cool"); */
  /**/
  /* /* print_direct(possible.directions, possible.coordinates); */
  /**/
  /* for (int i = 0; i < POSS_LENGTH; i++) { */
  /*   printf("( %i - ", possible.coordinates[i][0]); */
  /*   printf("%i )", possible.coordinates[i][1]); */
  /*   /* printf("\n"); */
  /* } */

  solve(grid, words, used_words);

  return 0;
}
